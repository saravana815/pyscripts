#!/usr/bin/expect -f
#
# This Expect script was generated by autoexpect on Tue Sep  3 11:02:07 2019
# Expect and autoexpect were both written by Don Libes, NIST.
# The modified custom changes to this script by sargandh@cisco.com
# Read README.txt for the new changes and usage
#

set force_conservative 0  ;# set to 1 to force conservative mode even if
                          ;# script wasn't run conservatively originally
if {$force_conservative} {
        set send_slow {1 .1}
        proc send {ignore arg} {
                sleep .1
                exp_send -s -- $arg
        }
}

#proc loop_this - easy tcl for loop checks
#Usage: loop_this COUNT { TCL code block }

proc loop_this {count cblock} {
    for {set i 1} {$i <= $count} {incr i} {
        uplevel 1 "eval {$cblock}"
    }
}

#proc for verifying show output with expect buffer

proc verify_this_output {line} {
    global expect_out
    send_log "\n----------------------------------------------------\n"
    send_log "Checking for the below line to be present on ouptut\n"
    send_log "$line"
    send_log "\n----------------------------------------------------\n"

    #Delimited string check. example #(16.100.0.14)     1     (FULL/DR)         00:00:37)
    #Get delimited string list and form regexp with delimited strings joined by tcl .*
    set string_list [regexp -all -line -inline {\(.*?\)} $line]
    if {[llength $string_list] >= 1} {
        set string_regex {}
        set string_index 1
        set string_list_length [llength $string_list]
        foreach l $string_list {
            append string_regex [string trim $l "()"]
            if {$string_index < $string_list_length} {
                append string_regex {.*}
            }
            incr string_index
        }
        if {[regexp -line "$string_regex" $expect_out(buffer)] == 1} {
            send_log "PASS: Line {$line} found on output"
            send_log "\nTCL regexp used: {$string_regex}"
            send_log "\n----------------------------------------------------\n"
       } else {
            send_log "FAIL: Line {$line} not found on output"
            send_log "\nTCL regexp used: {$string_regex}"
            send_log "\n----------------------------------------------------\n"
       }
   } else {
        #Perform complete line match
        if {[regexp -line "$line" $expect_out(buffer)] == 1} {
            send_log "PASS: Line {$line} found on output"
            send_log "\n----------------------------------------------------\n"
       } else {
            send_log "FAIL: Line {$line} not found on output"
            send_log "\n----------------------------------------------------\n"
        }
    }
}

if {[llength $argv] <= 1} {
  puts "\n"
  puts "Usage: ./ssh_login_ios.exp rtr_hostname \"{show version} {show ip route summary}\""
  puts "Usage: ./ssh_login_ios.exp rtr_hostname -i"
  puts "\n"
  exit
}

set timeout 600
#set logfile "logs/script_log_[clock  seconds]"
#log_file $logfile

#puts $argv puts [lindex $argv 0] puts [lindex $argv 1] puts [lindex $argv 2]

set hostname [string tolower [lindex $argv 0]]
set cmds [lindex $argv 1]

spawn ssh $hostname
set prompt "(>|%|#|\\\$)$"

match_max 100000
expect {
  -nocase "Password:" { send -- "C!sc0123\r" }
  -nocase "Are you sure you want to continue connecting" { send -- "yes\r"; exp_continue }
}
expect -nocase "$prompt"
send -- "enable\r"
expect -nocase "Password:"
send -- "C!sc0123\r"
expect -nocase "$prompt"

if {[lindex $argv 1] == "-i" || [lindex $argv 2] == "-i"} {
  interact
  exit
}

send -- "term len 0\r"
expect -nocase "$prompt"

foreach cmd $cmds {
  send -- "$cmd\r"
  #expect -nocase "$prompt"
  expect -re $prompt
}
#send -- "sh ip route sum\r"
#expect -nocase "$prompt"

send -- "exit\r"
expect eof

